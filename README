FUSE S3QLFS
===========

Copyright (c) 2008 Nikolaus Rath <Nikolaus@rath.org>


This program allows to mount an Amazon S3 bucket as a filesystem. Its
design is based on the following principles:

 - Reliability. S3qlfs has been built with solid error detection and
   error handling starting from the very first line. All filesystem
   tools have been written in a high-level language (Python), thus
   eliminating whole classes of bugs and reducing the likelyhood of
   the remaining ones.

 - Code Quality. Care has been taken to make the code as readable and
   serviceable as possible. Priority has always been on better code
   rather than better performance.

 - Data Safety. Even in the unlikely event that at some point in the
   future S3qlfs will no longer be available, all data can still be
   retrieved and reassembled from S3 using simple shell commands.
   (unless you used encryption, that is)
 
 - Compatibility with Amazon's new S3 pricing model. The number of
   HTTP requests is minimized.

 - Suitability as a backend for the storeBackup backup program. This
   means it is optimized to handle hardlink operations very quickly
   (actually, no S3 request is required for any metadata operation)
   and to efficiently handle the sequential writing and reading of
   files with wildly different sizes.


COMPARISON TO OTHER S3 STORAGE METHODS
--------------------------------------

An alternative method to store data on Amazon S3 is to use it as a
block device for a "real" filesystem like ext3 or XFS. Such an
approach is implemented e.g. in s3backer
(http://code.google.com/p/s3backer/). This approach has some
advantages, mainly that

 1. The code can be kept much simpler, since no filesystem semantics
    have to be reimplemented
    
 2. Cryptography, extended attributes and other advanced features all
    come for free.

However, this approach also has some drawbacks:

 - The filesystem cannot dynamically grow and shrink. Since the block
   device layer has no information about the usage of any block,
   deleting a file will not result in less space occupied on S3.

 - Since the blocksize is usually rather small (e.g. 64 KB) and very
   huge number of requests is needed to store data (e.g. 16386
   requests for 1 GB of data). On the other hand if one increases the
   blocksize, even simple operations like chmod() will result in very
   large network operations.

   
For this reason, s3qlfs was created. It avoids the abovementioned
issues by design but indeed needs to provide a full filesystem
implementation. However, there are a number of factors that mitigate
the required complexity:

 - Many filesystem semantics are already implemented in FUSE (most
   notably both user-level and internal file locking)
 
 - By designing the filesystem in user space and using a high level
   language, the task becomes significantly easier than the design of
   a kernel file system.

 - Since a filesystem is basically a database, s3qlfs is using an
   actual, well tested SQL database (SQLite) to manage all its
   metadata and does not have to implement any database features
   itself.
   

USAGE NOTES
-----------


  1. Do not mount the filesystem more than once.

  2. Wait a sufficient amount of time between subsequent mounts.

  3. S3QL tries to enforce both of the above rules, but it cannot do
     so reliably by design. Thus it really is *your* responsibility.

Having read, understood, and memorized the above, you can get started by
obtaining an Amazon S3 account from http://aws.amazon.com/. Write your
AWS access key and your AWS password into the file .awssecret in your
home directory (separated by newlines).

Then create the filesystem with

  # mkfs.s3ql <bucketname>
  

Now you can mount your filesystem using

  # s3qlfs <bucketname> <mountpoint>
  

IF SOMETHING BREAKS
-------------------

If the network connection (or the whole system) breaks down while the
file system is mounted, you should try to run fsck.s3ql on the machine
where the filesystem was last mounted and by the user who did the last
mount. This allows to commit any changes that are still cached locally
and to recover the metadata.

If you run fsck.s3ql on a different machine, it will still bring the
filesystem in a consistent state, but you will probably loose much
more data.

     

IMPLEMENTATION NOTES
--------------------
  
S3QL stores all filesystem metadata in a single SQL table that is
retrieved from S3 when the filesystem is mounted and written back
periodically. This means that you *must not* mount the same bucket
more than once. Any attempt to do so will invariantly lead to one
metadata table being overwritten and the actual file contents being
mixed randomly.

It is important to know that changes in the S3 bucket need some time
to propagate. That means that if one reads data from S3 directly after
it has been written, one may still get the old data back. Once the
filesystem has been mounted, it automatically handles such situations
internally. However, this propagation delay means that the filesystem
cannot reliably detect multiple mounts, hence the user is responsible
to prevent this.

Moreover, the propagation delay also means that the filesystem must
not be mounted again before all changes have propagated through S3.
Once again, this cannot be reliably checked by the filesystem itself,
so the user needs to take care that a sufficient amount of time lies
between individual mounts.

Amazon does not publish any information on how long propagation may
take. However, in my own tests, it never needed more than 50 seconds.


Note: As implied above, the filesystem *tries* to detect these
conditions. This is done by using a very short marker object that is
set to "dirty" when the fs is mounted and to "clear" when the fs has
been unmounted. However, even these small objects may need time to
propagate, so this method is not reliable.

