.. -*- mode: rst -*-

=====================
Contributed Programs
=====================

S3QL comes with a few contributed programs that are not part of the
core distribution (and are therefore not installed automatically by
default), but which may nevertheless be useful. These programs are in
the `contrib` directory of the source distribution or in
`/usr/share/doc/s3ql/contrib` if you installed S3QL from a package.


benchmark.py
============

This program measures your uplink bandwidth and compression speed and
recommends a compression algorithm for optimal throughput.


s3_copy.py
==========

This program physically duplicates Amazon S3 bucket. It can be used to
migrate buckets to a different storage region or storage class
(standard or reduced redundancy).

.. _pcp:

pcp.py
======

``pcp.py`` is a wrapper program that starts several rsync processes to
copy directory trees in parallel. This is important because
transferring files in parallel significantly enhances performance when
copying data from an S3QL file system (see :ref:`copy_performance` for
details).

To recursively copy the directory ``/mnt/home-backup`` into
``/home/joe`` using 8 parallel processes and preserving permissions,
you would execute ::

  pcp.py -a --processes=8 /mnt/home-backup/ /home/joe


s3_backup.sh
============

This is an example script that demonstrates how to set up a simple but
powerful backup solution using S3QL and `rsync
<http://samba.org/rsync>`_.

The `s3_backup.sh` script automates the following steps:

#. Mount the file system
#. Replicate the previous backup with `s3qlcp`
#. Update the new copy with the data from the backup source using rsync
#. Delete old backups that are no longer needed
#. Unmount the file system

The
backups are stored in directories of the form `YYYY-MM-DD_HH:mm:SS` and the
`expire_backups.py`_ command is used to delete old backups.


expire_backups.py
=================

The ``expire_backups.py`` command deletes backups that are no longer
needed as defined by a specific backup strategy. A backup strategy is
defined by specifying a number of backup *generations* with their
relative ages.

Let's illustrate this with an example. A very common idea of a backup
strategy is to keep backups such that there is always at least one
backup from given number of points in the past. Naively, you could
formalize this by saying that you always want to have backups
available from the following dates:

* Yesterday
* 3 days ago
* A week ago
* A month ago
* 6 months ago

The first thing that you should realize is that this is actually most
likely *not* what you really want, because it would require you to do
daily backups and keep *every* backup for the full 6 months (otherwise
you wouldn't always have a backup that has *exactly* the requested
age). So what you probably mean by the above is that you would like to
have backups that are from different date *ranges*, like this:

* 1 hour to 24 hours ago
* 24 hours to 3 days ago
* 3 days to 7 days ago
* 7 days to 31 days ago
* 31 days to 6*31 ~ 180 days ago

However, this still is not perfect. Imagine that you go on vacation
for three weeks and don't do any backups. When you come back and do a
fresh backup, a program following your prescription would delete the
backups that you did right before your vacation because they're now 3
weeks old. So if later that day you want to recover a document that
you deleted one day before going on vacation, you'd be in for a big
disappointment because that backup has already been deleted.

The problem is that logically the backup that you did right before
your vacation is only 1 day old: since you did not change any data
while on vacation, this period can not be taken into account for
calculating backup ages. A really good backup strategy therefore only
considers *relative* ages between backup *generations*, e.g.

* Generation one: backups made 1 hour to 24 hours before the
  current backup
* Generation two: backups made 24 hours to 2 days before the first
  backup of generation one
* Generation three: backups made 2 days to 5 days before the first
  backup of generation two
* Generation four: backups made * 5 days to 26 days before the
  first backup of generation three
* Generation five: backups made * 26 days to 154 days before the
  first backup of generation four

The ``expire_backups.py`` command allows you to specify your backup
strategy in terms of such generations. It uses a sophisticated
algorithm that ensures that there will always be at least one backup
available in each generation. It deletes backups are deleted as soon
as they will no longer be required for any generation at any time
(both now and in the future).

``expire_backups.py`` usage is simple. It requires backups to have names of
the forms `year-month-day_hour:minute:seconds` (`YYYY-MM-DD_HH:mm:ss`)
and works on all backups in the current directory. The desired backup
generations are specified by listing their relative ages. So for the
above backup strategy, the correct invocation would be::

  expire_backups.py 1h 24h 2d 5d 26d 154d


For a full list of available options, run ``expire_backups.py --help``.

