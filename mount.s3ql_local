#!/usr/bin/env python
#
#    Copyright (C) 2008  Nikolaus Rath <Nikolaus@rath.org>
#
#    This program can be distributed under the terms of the GNU LGPL.
#

# Python boto uses several deprecated modules
import warnings
warnings.filterwarnings("ignore", "", DeprecationWarning, "boto")

from optparse import OptionParser
from getpass  import getpass
from time import sleep
import s3ql
import sys
import os
import tempfile
import apsw
import syslog

#
# Parse command line
#
parser = OptionParser(
    usage="%prog  [options] <mountpoint>\n"
          "       %prog --help",
    description="Emulates S3QL filesystem using in-memory storage"
    "instead of actually connecting to S3. Only for testing purposes.")

parser.add_option("--debug", action="store_true", default=False,
                  help="Generate debugging output")
parser.add_option("--quiet", action="store_true", default=False,
                  help="Be really quiet")
parser.add_option("--allow_others", action="store_true", default=False,
                  help="Allow others users to access the filesystem")
parser.add_option("--allow_root", action="store_true", default=False,
                  help="Allow root to access the filesystem")
parser.add_option("--nonempty", action="store_true", default=False,
                  help="Allow mount if even mount point is not empty")
parser.add_option("--fg", action="store_true", default=False,
                  help="Do not daemonize, stay in foreground")
parser.add_option("--single", action="store_true", default=False,
                  help="Single threaded operation only")
parser.add_option("--encrypt", action="store_true", default=None,
                  help="Create an AES encrypted filesystem")
parser.add_option("--blocksize", type="int", default=1,
                  help="Maximum size of s3 objects in KB (default: %default)")
parser.add_option("--fsck", action="store_true", default=False,
                  help="Runs fsck after the filesystem is unmounted.")
parser.add_option("--txdelay", type="float", default=0.0,
                  help="Simulated transmission time to/from S3 in seconds (default: %default)")
parser.add_option("--propdelay", type="float", default=0.0,
                  help="Simulated propagation in S3 in seconds (default: %default)")


(options, pps) = parser.parse_args()

#
# Verify parameters
#
if not len(pps) == 1:
    parser.error("Wrong number of parameters")
mountpoint = pps[0]


#
# Read password(s)
#
if options.encrypt:
    if sys.stdin.isatty():
        options.encrypt = getpass("Enter encryption password: ")
        if not options.encrypt == getpass("Confirm encryption password: "):
            print >>sys.stderr, "Passwords don't match."
            sys.exit(1)
    else:
        options.encrypt = sys.stdin.readline().rstrip()


#
# Pass on fuse options
#
fuse_opts = dict()
if options.allow_others:
    fuse_opts["allow_others"] = True
if options.allow_root:
    fuse_opts["allow_root"] = True
if options.nonempty:
    fuse_opts["nonempty"] = True
if options.single:
    fuse_opts["nothreads"] = True
if options.fg:
    fuse_opts["foreground"] = True

#
# Activate logging
#
if options.quiet:
    s3ql.log_level = 0
if options.debug:
    s3ql.log_level = 2


#
# Initialize local bucket
#

bucket = s3ql.s3.LocalBucket()
bucket.tx_delay = options.txdelay
bucket.prop_delay = options.propdelay


dbfile = tempfile.mktemp()
cachedir = tempfile.mkdtemp() + "/"
s3ql.setup_db(dbfile, options.blocksize * 1024)
s3ql.setup_bucket(bucket, dbfile)
s3ql.debug("Temporary database in " + dbfile)

#
# Start server
#
server = s3ql.server(bucket, dbfile, cachedir)

# Init syslog before going bg
if not options.fg:
    syslog.openlog("s3ql", 0, syslog.LOG_USER)
    def logger(args):
        msg = "".join(args)
        for line in msg.split("\n"):
            if len(line) == 0:
                continue
            syslog.syslog(line)

    s3ql.log_fn = logger

server.main(mountpoint, **fuse_opts)
server.close()

# We have to make sure that all changes have been comitted by the
# background threads
sleep(options.propdelay)

#
# Do fsck
#
if options.fsck:
    conn = apsw.Connection(dbfile)
    cursor = conn.cursor()

    if not ( \
        s3ql.fsck.a_check_parameters(conn, checkonly=True) and
        s3ql.fsck.b_check_cache(conn, cachedir, bucket, checkonly=True) and
        s3ql.fsck.c_check_contents(conn, checkonly=True) and
        s3ql.fsck.d_check_inodes(conn, checkonly=True) and
        s3ql.fsck.e_check_s3(conn, bucket, checkonly=True) and
        s3ql.fsck.f_check_keylist(conn, bucket, checkonly=True)
        ):
        print "fsck found errors -- preserving database in " + dbfile
        conn.close()
        os.rmdir(cachedir)
        sys.exit(1)
    else:
        conn.close()
        os.unlink(dbfile)
        os.rmdir(cachedir)
        sys.exit(0)
else:
    os.unlink(dbfile)
    os.rmdir(cachedir)
    sys.exit(0)
