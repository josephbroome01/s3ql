#!/usr/bin/env python
#
#    Copyright (C) 2008  Nikolaus Rath <Nikolaus@rath.org>
#
#    This program can be distributed under the terms of the GNU LGPL.
#


import traceback
import errno
import sys
import os
from itertools import chain
import functools
import s3ql
import hashlib
import stat
from getpass import getpass

def fuse_request_handler(fn):
    """Top Level Exception Handler for FUSE.

    If a FUSE request handler throws an exception almost all
    information about the exception is lost, since only the
    errno value can be reported to the caller. Moreover, the
    default global exception handler prints to stdout, which is also
    lost since FUSE is running as a daemon.

    Therefore, this function should be set as global exception
    handler instead. It logs the exception using the defined
    facilities and marks the filesystem as needing fsck.

    FIXME: Unfortunately, FUSE Python currently catches all
    OSError and IOError exceptions, so they are "lost" completely.

    FIXME: Code does not yet correspond to documentation.
    """

    @functools.wraps(fn)
    def wrapped(self, *a, **kw):
        if hasattr(self, "fs"):
            fs = self.fs
            pathinfo = " [path=%s]" % self.path
        else:
            fs = self
            pathinfo = ""

        fname = fn.__name__.rstrip("_i")

        # Print request name and parameters
        if fname == "write": # Special case: very large parameters
            ap = ("<data>",) + a[1:]
        else:
            ap = a
        debug("* Received FUSE request %s(%s)%s" %
              (fname, ", ".join(map(repr, chain(ap, kw.values()))),
               pathinfo))

        try:
            ret = fn(self, *a, **kw)
            if fname == "__init__": # Constructors don't return values
                ret = None
        except s3qlError, e:
            error([str(e), "\n",
                   e.fatal and "fs has probably been damaged, run s3fsck as soon as possible\n" or "\n",
                   "path: %s, inode: %s, s3key: %s" % (e.path, e.inode, e.s3key) ]
                  + traceback.format_tb(sys.exc_info()[2]))
            if e.fatal:
                fs.mark_damaged()
            raise

        except:
            error(["internal fs error:\n", str(sys.exc_info()[1]), "\n",
                   "please report this as a bug!\n",
                   "fs has probably been damaged, run s3fsck as soon as possible\n"]
                  + traceback.format_tb(sys.exc_info()[2]))
            fs.mark_damaged()
            raise
        return ret

    return wrapped



class s3qlError(IOError):
    """Class for exceptions generated by s3ql

    Inherits from IOError so that FUSE detects and reports the correct
    errno.

    Attributes
    ----------

    :errno:  Errno to return to FUSE
    :desc:   Detailed text error message
    :fatal:  Should be set if the error left the filesystem in an inconsistent state

    :path:   The path for which the error occured (if applicable)
    :inode:  The inode for which the error occured (if applicable)
    :s3key:  The s3 object key for which the error occured (if applicable)
    """

    def __init__(self, desc, errno=errno.EIO, path=None, inode=None,
                 s3key = None, fatal=False):
        self.errno = errno
        self.desc = desc
        self.path = path
        self.inode = inode
        self.s3key = s3key
        self.fatal = fatal

    def __str__(self):
        return self.desc



# log function and log level, should be overridden by importer
def debug(arg):

    """ Log message if debug output has been activated
    """

    if s3ql.log_level < 1:
        return

    if type(arg) != type([]):
        arg = [arg, "\n"]

    s3ql.log_fn(arg)

def error(arg):
    """ Log error message
    """

    if type(arg) != type([]):
        arg = [arg, "\n"]

    s3ql.log_fn(arg)


def get_cachedir(bucketname):
    """get directory to put cache files in.
    """

    path = os.environ["HOME"].rstrip("/") + "/.s3ql"

    if not os.path.exists(path):
        os.mkdir(path)

    return path + ("/%s-cache/" % bucketname)


def get_dbfile(bucketname):
    """get filename for metadata db.
    """

    path = os.environ["HOME"].rstrip("/") + "/.s3ql"

    if not os.path.exists(path):
        os.mkdir(path)

    return path + ("/%s.db" % bucketname)


def get_credentials(key=None):
    """Get AWS credentials.

    If `key` has been specified, use this as access key and
    read the password from stdin. Otherwise, tries to read
    ~/.awssecret.
    """


    if key:
        if sys.stdin.isatty():
            pw = getpass("Enter AWS password: ")
        else:
            pw = sys.stdin.readline().rstrip()
        return (key, pw)

    # Read file
    path = os.environ["HOME"].rstrip("/") + "/.awssecret"
    mode = os.stat(path).st_mode
    if mode & stat.S_IRGRP or \
            mode & stat.S_IROTH:
        sys.stderr.write("%s has insecure permissions, bailing out\n" % path)
        sys.exit(1)
    file = open(path, "r")
    awskey = file.readline().rstrip()
    pw = file.readline().rstrip()

    return (awskey, pw)
