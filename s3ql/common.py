#!/usr/bin/env python
#
#    Copyright (C) 2008  Nikolaus Rath <Nikolaus@rath.org>
#
#    This program can be distributed under the terms of the GNU LGPL.
#


import traceback
import errno
from itertools import chain
import functools

def fuse_request_handler(fn):
    """Wraps the calls to FUSE request handlers

    If a FUSE request handler throws an exception almost all
    information about the exception is lost, since only the
    errno value can be reported to the caller.

    For this reason, the fuse_request_handler is supposed to
    be used as a decorator for all request handling functions.
    It wraps the handler function and logs all exceptions.
    If the exception specifies so, it also marks the filesystem
    as needing fsck.
    """

    @functools.wraps(fn)
    def wrapped(self, *a, **kw):
        if hasattr(self, "fs"):
            fs = self.fs
            pathinfo = " [path=%s]" % self.path
        else:
            fs = self
            pathinfo = ""

        fname = fn.__name__.rstrip("_i")

        # Print request name and parameters
        if fname == "write": # Special case: very large parameters
            a[0] = buffer(a[0])

        debug("* Received FUSE request %s(%s)%s" %
              (fname, ", ".join(map(repr, chain(a, kw.values()))),
               pathinfo))

        try:
            if fname == "__init__": # Constructors don't return values
                fn(self, *a, **kw)
            else:
                return fn(self, *a, **kw)
        except s3qlException, e:
            error([str(e), "\n",
                   e.fatal and "fs has probably been damaged, run s3fsck as soon as possible\n" or "\n",
                   "path: %s, inode: %s, s3key: %s" % (e.path, e.inode, e.s3key) ]
                  + traceback.format_tb(sys.exc_info()[2]))
            if e.fatal:
                fs.mark_damaged()
            raise

        except Exception, e:
            error(["internal fs error:\n", str(e), "\n",
                   "please report this as a bug!\n",
                   "fs has probably been damaged, run s3fsck as soon as possible\n"]
                  + traceback.format_tb(sys.exc_info()[2]))
            fs.mark_damaged()
            raise
    return wrapped



class s3qlError(IOError):
    """Class for exceptions generated by s3qlfs

    Inherits from IOError so that FUSE detects and reports the correct
    errno.

    Attributes
    ----------

    :errno:  Errno to return to FUSE
    :desc:   Detailed text error message
    :fatal:  Should be set if the error left the filesystem in an inconsistent state

    :path:   The path for which the error occured (if applicable)
    :inode:  The inode for which the error occured (if applicable)
    :s3key:  The s3 object key for which the error occured (if applicable)
    """

    def __init__(self, desc, errno=errno.EIO, path=None, inode=None,
                 s3key = None, fatal=False):
        self.errno = errno
        self.desc = desc
        self.path = path
        self.inode = inode
        self.s3key = s3key
        self.fatal = fatal

    def __str__(self):
        return self.desc



def debug(arg):
    """ Log message if debug output has been activated
    """

    if not debug_enabled:
        return

    if type(arg) != type([]):
        arg = [arg, "\n"]

    print "".join(arg),


def error(arg):
    """ Log error message
    """

    if type(arg) != type([]):
        arg = [arg, "\n"]

    print >>sys.stderr, "".join(arg),
