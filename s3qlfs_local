#!/usr/bin/env python
#
#    Copyright (C) 2008  Nikolaus Rath <Nikolaus@rath.org>
#
#    This program can be distributed under the terms of the GNU LGPL.
#

from optparse import OptionParser
from getpass  import getpass
import s3ql
import sys
import os
import tempfile
import apsw
import syslog

#
# Parse command line
#
parser = OptionParser(
    usage="%prog  [options] <mountpoint>\n"
          "       %prog --help",
    description="Emulates S3QL filesystem using in-memory storage"
    "instead of actually connecting to S3. Only for testing purposes.")

parser.add_option("--debug", action="store_true", default=False,
                  help="Generate debugging output")
parser.add_option("--quiet", action="store_true", default=False,
                  help="Be really quiet")
parser.add_option("--allow_others", action="store_true", default=False,
                  help="Allow others users to access the filesystem")
parser.add_option("--allow_root", action="store_true", default=False,
                  help="Allow root to access the filesystem")
parser.add_option("--nonempty", action="store_true", default=False,
                  help="Allow mount if even mount point is not empty")
parser.add_option("--fg", action="store_true", default=False,
                  help="Do not daemonize, stay in foreground")
parser.add_option("--single", action="store_true", default=False,
                  help="Single threaded operation only")
parser.add_option("--encrypt", action="store_true", default=None,
                  help="Create an AES encrypted filesystem")
parser.add_option("--blocksize", type="int", default=1,
                  help="Maximum size of s3 objects in KB (default: %default)")
parser.add_option("--fsck", action="store_true", default=False,
                  help="Runs fsck after the filesystem is unmounted.")


(options, pps) = parser.parse_args()

#
# Verify parameters
#
if not len(pps) == 1:
    parser.error("Wrong number of parameters")
mountpoint = pps[0]


#
# Read password(s)
#
if options.encrypt:
    if sys.stdin.isatty():
        options.encrypt = getpass("Enter encryption password: ")
        if not options.encrypt == getpass("Confirm encryption password: "):
            print >>sys.stderr, "Passwords don't match."
            sys.exit(1)
    else:
        options.encrypt = sys.stdin.readline().rstrip()


#
# Pass on fuse options
#
fuse_opts = []
if options.allow_others:
    fuse_opts.append("allow_others")
if options.allow_root:
    fuse_opts.append("allow_root")
if options.nonempty:
    fuse_opts.append("nonempty")


#
# Activate logging
#
if options.quiet:
    s3ql.log_level = 0
if options.debug:
    s3ql.log_level = 2


#
# Initialize local bucket
#

bucket = s3ql.s3.LocalBucket()
bucket.tx_delay = 0
bucket.prop_delay = 0.2


dbfile = tempfile.mktemp()
cachedir = tempfile.mkdtemp() + "/"
s3ql.setup_db(dbfile, options.blocksize * 1024)
s3ql.setup_bucket(bucket, dbfile)



#
# Start server
#
server = s3ql.fs(bucket, dbfile, cachedir)

# Init syslog before going bg
if not options.fg:
    syslog.openlog("s3ql", 0, syslog.LOG_USER)
    def logger(args):
        msg = "".join(args)
        for line in msg.split("\n"):
            if len(line) == 0:
                continue
            syslog.syslog(line)

    s3ql.log_fn = logger


setup_excepthook(server)
server.main(mountpoint, fuse_opts, fg=options.fg,
            mt=not options.single)
server.close()

#
# Do fsck
#
ok = True
if options.fsck:
    conn = apsw.Connection(dbfile)
    cursor = conn.cursor()

    if not ( \
        s3ql.fsck.a_check_parameters(conn, checkonly=True) and
        s3ql.fsck.b_check_cache(conn, cachedir, bucket, checkonly=True) and
        s3ql.fsck.c_check_contents(conn, checkonly=True) and
        s3ql.fsck.d_check_inodes(conn, checkonly=True) and
        s3ql.fsck.e_check_s3(conn, bucket, checkonly=True) and
        s3ql.fsck.f_check_keylist(conn, bucket, checkonly=True)
        ):
        ok = False

    conn.close()

os.unlink(dbfile)
os.rmdir(cachedir)

if ok:
    sys.exit(0)
else:
    sys.exit(1)
